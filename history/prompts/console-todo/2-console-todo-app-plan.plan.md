---
id: 2
title: Console Todo App Plan
stage: plan
date: 2025-12-29
surface: agent
model: claude-sonnet-4-5-20250929
feature: console-todo
branch: master
user: user
command: sp.plan
labels: [plan,console,todo,phase1]
links:
  spec: phase-1/specs/001_console_mvp.md
  ticket: null
  adr: null
  pr: null
files:
 - phase-1/plan.md
 - phase-1/research.md
 - phase-1/data-model.md
 - phase-1/contracts/api-contracts.md
 - phase-1/quickstart.md
tests:
 - pytest requirements for todo features
---

## Prompt

@skills/project-management
I have reviewed `phase-1/specs/001_console_mvp.md` and it looks good.
Now, create a **Implementation Plan** and break it down into **Tasks**.

1. Create a file `phase-1/plan.md` listing the step-by-step implementation plan.
2. The plan should cover:
   - Setting up project structure.
   - Creating the Task Model class.
   - Implementing the Service/Manager logic (CRUD operations).
   - Implementing the CLI Menu (Interface).
   - Writing Tests.

## Response snapshot

# Console Todo App Implementation Plan

## Technical Context

**Feature:** Console Todo App (Phase I of "Evolution of Todo" project)
**Location:** phase-1/
**Target:** Python 3.13+ console application with in-memory storage
**Constitution Compliance:** All code will be AI-generated based on specification, following spec-driven development principles

## Constitution Check

- ‚úÖ AI-Generated Code Only: All implementation will be generated by AI based on this specification
- ‚úÖ Spec-Driven Development: Implementation follows from the formal specification in phase-1/specs/001_console_mvp.md
- ‚úÖ Technology Stack Adherence: Using Python 3.13+, FastAPI & SQLModel (for later phases), in-memory storage for this phase
- ‚úÖ Global Operational Rules: Following PEP 8, using conventional commits, updating spec before code changes
- ‚úÖ Testing & Validation: All features will have mandatory tests as defined in the specification

## Implementation Phases

### Phase 0: Project Setup and Research

**Research Tasks:**
1. **Python Project Structure Research**
   - Decision: Use standard Python project layout with src/, tests/, and pyproject.toml
   - Rationale: Follows Python community best practices and enables proper packaging
   - Alternatives considered: Simple script vs. structured project - structured approach chosen for maintainability

2. **Rich Library Integration Research**
   - Decision: Implement rich library for enhanced console UI with fallback to standard print
   - Rationale: Provides better user experience with tables, colors, and formatting
   - Alternatives considered: Standard print statements vs. rich library - rich chosen for better UX

3. **Task Management Pattern Research**
   - Decision: Use object-oriented approach with Task class and TodoManager service class
   - Rationale: Encapsulates data and behavior, making code more maintainable and testable
   - Alternatives considered: Procedural vs. OOP approach - OOP chosen for better structure

### Phase 1: Data Model and Contracts

**Data Model (data-model.md)**

```
Entity: Task
Fields:
- id: integer (auto-generated, unique within session)
- title: string (required, non-empty)
- description: string (optional)
- status: enum (complete, incomplete)
- priority: enum (low, medium, high)

Validations:
- id must be unique within application session
- title must not be empty when creating task
- status must be one of defined values
- priority must be one of defined values

State Transitions:
- status: incomplete ‚Üí complete (via mark_complete)
- status: complete ‚Üí incomplete (via mark_incomplete)
```

**API Contracts (contracts/)**

1. **Task Creation Contract**
   - Function: create_task(title: str, description: str, priority: str) -> Task
   - Validates: title is not empty, priority is valid enum
   - Returns: Task object with assigned ID and "incomplete" status

2. **Task Retrieval Contract**
   - Function: get_all_tasks() -> List[Task]
   - Returns: All tasks in creation order

3. **Task Update Contract**
   - Function: update_task(task_id: int, title: str, description: str, priority: str) -> bool
   - Validates: task exists, title is not empty
   - Returns: True if successful, False if task not found

4. **Task Deletion Contract**
   - Function: delete_task(task_id: int) -> bool
   - Validates: task exists
   - Returns: True if successful, False if task not found

5. **Task Status Update Contract**
   - Function: update_task_status(task_id: int, status: str) -> bool
   - Validates: task exists, status is valid enum
   - Returns: True if successful, False if task not found

### Phase 2: Implementation Plan

**Step 1: Project Structure Setup**
- Create project directory structure
- Set up pyproject.toml with dependencies (python 3.13+, rich, pytest)
- Initialize git repository with proper .gitignore

**Step 2: Task Model Implementation**
- Create Task class with id, title, description, status, and priority attributes
- Implement validation logic for required fields
- Create enum classes for status and priority values
- Add string representation for display purposes

**Step 3: Service/Manager Logic Implementation**
- Create TodoManager class to handle CRUD operations
- Implement in-memory storage using Python lists/dictionaries
- Implement add_task method with validation
- Implement get_all_tasks method
- Implement update_task method with validation
- Implement delete_task method with confirmation
- Implement mark_task_complete/incomplete methods

**Step 4: CLI Menu Interface Implementation**
- Create main application loop
- Implement menu display with options (Add, View, Update, Delete, Mark Complete, Exit)
- Implement input validation and error handling
- Create user-friendly prompts and feedback messages
- Handle invalid inputs gracefully

**Step 5: Testing Implementation**
- Write unit tests for Task model
- Write unit tests for TodoManager CRUD operations
- Write integration tests for CLI flow
- Test error handling scenarios
- Test data validation requirements
- Ensure 95%+ success rate requirements from spec are met

## Dependencies and Assumptions

**Dependencies:**
- Python 3.13+ runtime
- Rich library for enhanced console UI
- Pytest for testing framework

**Assumptions:**
- Application runs in standard terminal environment
- Users familiar with command-line interfaces
- Data persistence not required (in-memory only)
- Sequential integer IDs starting from 1

## Success Criteria Verification Plan

- Test task creation completion time (target: under 30 seconds)
- Verify formatted task display with all required information
- Validate 95% success rate for update operations
- Validate 95% success rate for delete operations with confirmation
- Validate 95% success rate for status change operations
- Verify 2-second response time for all inputs
- Test 99% uptime during usage (no crashes)
- Test error handling prevents crashes (99% success rate)

## Risk Mitigation

1. **Input Validation Risks**
   - Mitigation: Comprehensive validation at all user input points
   - Testing: Edge cases and invalid inputs covered in test suite

2. **Memory Management Risks**
   - Mitigation: Simple in-memory storage with no complex data structures
   - Testing: Multiple operations to ensure data integrity

3. **User Experience Risks**
   - Mitigation: Rich library for better UI, clear error messages
   - Testing: User flow testing to ensure intuitive navigation

## Outcome

- ‚úÖ Impact: Created comprehensive implementation plan for console todo app
- üß™ Tests: Defined testing approach for all features
- üìÅ Files: Created plan, research, data model, contracts, and quickstart files
- üîÅ Next prompts: Ready for task breakdown and implementation
- üß† Reflection: Plan covers all required components with proper architecture

## Evaluation notes (flywheel)

- Failure modes observed: none
- Graders run and results (PASS/FAIL): PASS
- Prompt variant (if applicable): N/A
- Next experiment (smallest change to try): Begin task breakdown based on plan